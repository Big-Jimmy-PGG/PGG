// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"kv0No":[function(require,module,exports) {
var _lib = require("../lib");
const n = new (0, _lib.Network)("d0fe1ca1-7fa0-47ed-9469-6c792f68bae0");
window.n = n;
const inp = document.getElementById("input");
const out = document.getElementById("output");
const log = (text)=>{
    console.log(text);
    if (out?.innerText != null) {
        const time = new Date().toLocaleTimeString();
        out.value += `[${time}] ${text.trim()}\n`;
        out.scrollTop = out.scrollHeight;
    }
};
n.on("ready", ()=>{
    log("network ready");
    n.on("message", (peer, channel, data)=>{
        if (channel === "reliable") log(`${peer.id} said "${data}" via ${channel}`);
    });
    inp.addEventListener("keyup", (e)=>{
        if (e.key === "Enter") {
            log(`sending ${inp.value}`);
            n.broadcast("reliable", inp.value);
            inp.value = "";
        }
    });
    document.querySelector('a[data-action="create"]')?.addEventListener("click", ()=>{
        if (n.currentLobby === undefined) n.create({
            codeFormat: "short",
            public: true
        });
    });
    document.querySelector('a[data-action="join"]')?.addEventListener("click", ()=>{
        if (n.currentLobby === undefined) {
            const code = prompt("Lobby code? (empty to create a new one)");
            if (code != null && code !== "") n.join(code);
        }
    });
    const queryLobbies = ()=>{
        console.log("querying lobbies...");
        n.list().then((lobbies)=>{
            console.log("queried lobbies:", lobbies);
            const el = document.getElementById("lobbies");
            if (el !== null) {
                el.innerHTML = "";
                if (lobbies === null || lobbies.length === 0) {
                    const li = document.createElement("li");
                    li.innerHTML = "<i>no lobbies</i>";
                    el.appendChild(li);
                } else lobbies.forEach((lobby)=>{
                    const li = document.createElement("li");
                    li.id = lobby.code;
                    li.innerHTML = `<a href="javascript:void(0)" class="code">${lobby.code}</a> - <span class="players">${lobby.playerCount}</span> players`;
                    el.appendChild(li);
                    if (n.currentLobby === undefined) li.querySelector("a.code")?.addEventListener("click", ()=>{
                        n.join(lobby.code);
                    });
                });
            }
        });
    };
    queryLobbies();
    setInterval(queryLobbies, 5000);
});
n.on("lobby", (code)=>{
    log(`lobby code ready: ${code} (and you are ${n.id})`);
    const li = document.createElement("li");
    li.id = n.id;
    li.innerHTML = `${n.id} <span>me${n.id === n.currentLobbyLeader ? ", leader" : ""}</span> (ping: <span>0</span>)`;
    document.getElementById("peers")?.appendChild(li);
});
n.on("signalingerror", console.error.bind(console.error));
n.on("rtcerror", console.error.bind(console.error));
n.on("connecting", (peer)=>{
    log(`peer connecting ${peer.id}`);
});
n.on("disconnected", (peer)=>{
    log(`peer disconnected ${peer.id} (${n.size} peers now)`);
    document.getElementById(peer.id)?.remove();
});
n.on("connected", (peer)=>{
    window.peer = peer;
    log(`peer connected: ${peer.id} (${n.size} peers now)`);
    n.broadcast("reliable", `got new peer! ${peer.id}`);
    const li = document.createElement("li");
    li.id = peer.id;
    li.innerHTML = `${peer.id} <span>${peer.id === n.currentLobbyLeader ? "leader" : ""}</span> (ping: <span>0</span>)`;
    document.getElementById("peers")?.appendChild(li);
    setInterval(()=>{
        li.querySelector("span:nth-child(2)").innerHTML = `${peer.latency.average.toFixed(1)}ms ${peer.latency.jitter.toFixed(1)}ms`;
        n.send("unreliable", peer.id, "bogus data");
    }, 16);
});
n.on("leader", ()=>{
    document.querySelectorAll("#peers li span").forEach((el)=>{
        const id = el.parentElement?.id;
        const parts = [];
        if (id === n.id) parts.push("me");
        if (el.parentElement?.id === n.currentLobbyLeader) parts.push("leader");
        el.innerHTML = parts.join(", ");
    });
});

},{"../lib":"b74RF"}],"b74RF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Network", ()=>(0, _networkDefault.default));
parcelHelpers.export(exports, "DefaultSignalingURL", ()=>DefaultSignalingURL);
parcelHelpers.export(exports, "DefaultRTCConfiguration", ()=>DefaultRTCConfiguration);
parcelHelpers.export(exports, "DefaultDataChannels", ()=>DefaultDataChannels);
var _credentials = require("./credentials");
var _network = require("./network");
var _networkDefault = parcelHelpers.interopDefault(_network);
const DefaultSignalingURL = "ws://localhost:8080/v0/signaling";
const DefaultRTCConfiguration = {
    iceServers: [
        {
            urls: [
                "stun:stun.l.google.com:19302"
            ]
        },
        {
            urls: (0, _credentials.PokiTurnMatch)
        }
    ]
};
const DefaultDataChannels = {
    reliable: {
        ordered: true
    },
    unreliable: {
        ordered: true,
        maxRetransmits: 0
    },
    control: {
        ordered: false
    }
};

},{"./credentials":"aZfNA","./network":"e2FW8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aZfNA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PokiTurnMatch", ()=>PokiTurnMatch);
const FetchTimeout = 5000;
const PokiTurnMatch = "turn:turn.rtc.poki.com";
class Credentials {
    constructor(signaling){
        this.signaling = signaling;
        this.cachedCredentialsExpireAt = 0;
    }
    async fillCredentials(config) {
        const cloned = JSON.parse(JSON.stringify(config));
        if (config.testproxyURL !== undefined) return cloned;
        const hasPokiTurn = cloned.iceServers?.some((s)=>s.urls === PokiTurnMatch || s.urls.includes(PokiTurnMatch)) ?? false;
        if (!hasPokiTurn || cloned.iceServers === undefined) return cloned;
        if (this.runningPromise === undefined) this.runningPromise = new Promise((resolve)=>{
            if (this.cachedCredentials != null && this.cachedCredentialsExpireAt > performance.now()) {
                resolve(this.cachedCredentials);
                return;
            }
            this.signaling.request({
                type: "credentials"
            }).then((credentials)=>{
                if (credentials.type === "credentials") {
                    this.cachedCredentials = credentials;
                    this.cachedCredentialsExpireAt = performance.now() + ((credentials.lifetime ?? 0) - 60) * 1000;
                    resolve(credentials);
                }
            }).catch(()=>{
                resolve({
                    type: "credentials"
                });
                this.cachedCredentials = {
                    type: "credentials"
                };
                this.cachedCredentialsExpireAt = performance.now() + FetchTimeout;
            });
            setTimeout(()=>{
                resolve({
                    type: "credentials"
                });
                this.cachedCredentials = {
                    type: "credentials"
                };
                this.cachedCredentialsExpireAt = performance.now() + FetchTimeout;
            }, FetchTimeout);
        });
        const credentials = await this.runningPromise;
        this.runningPromise = undefined;
        if (credentials.url === undefined) return cloned;
        cloned.iceServers.forEach((s)=>{
            if (s.urls === PokiTurnMatch || s.urls.includes(PokiTurnMatch)) {
                s.urls = credentials.url ?? "";
                s.username = credentials.username;
                s.credential = credentials.credential;
            }
        });
        return cloned;
    }
}
exports.default = Credentials;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"e2FW8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventemitter3 = require("eventemitter3");
var _ = require(".");
var _signaling = require("./signaling");
var _signalingDefault = parcelHelpers.interopDefault(_signaling);
var _peer = require("./peer");
var _peerDefault = parcelHelpers.interopDefault(_peer);
var _credentials = require("./credentials");
var _credentialsDefault = parcelHelpers.interopDefault(_credentials);
class Network extends (0, _eventemitter3.EventEmitter) {
    constructor(gameID, rtcConfig = (0, _.DefaultRTCConfiguration), signalingURL = (0, _.DefaultSignalingURL)){
        super();
        this.gameID = gameID;
        this.rtcConfig = rtcConfig;
        this._closing = false;
        this.dataChannels = (0, _.DefaultDataChannels);
        this.log = (...args)=>{} // console.log
        ;
        this.peers = new Map();
        this.signaling = new (0, _signalingDefault.default)(this, this.peers, signalingURL);
        this.credentials = new (0, _credentialsDefault.default)(this.signaling);
        this.unloadListener = ()=>this.close();
        if (typeof window !== "undefined") window.addEventListener("unload", this.unloadListener);
    }
    async list(filter) {
        if (this._closing || this.signaling.receivedID === undefined) return [];
        const reply = await this.signaling.request({
            type: "list",
            filter
        });
        if (reply.type === "lobbies") return reply.lobbies;
        return [];
    }
    async create(settings) {
        if (this._closing || this.signaling.receivedID === undefined) return "";
        const reply = await this.signaling.request({
            type: "create",
            ...settings
        });
        if (reply.type === "joined") return reply.lobby;
        return "";
    }
    async join(lobby) {
        if (this._closing || this.signaling.receivedID === undefined) return;
        await this.signaling.request({
            type: "join",
            lobby
        });
    }
    async setCustomData(customData) {
        if (this._closing || this.signaling.receivedID === undefined) return "network is closing or not connected";
        if (this.signaling.receivedID !== this.signaling.currentLobbyLeader) return "only the lobby leader can update custom data";
        const reply = await this.signaling.request({
            type: "update",
            customData
        });
        if (reply.type === "updated") {
            if (reply.error === undefined) return true;
            return reply.error;
        }
        return "";
    }
    close(reason) {
        if (this._closing || this.signaling.receivedID === undefined) return;
        this._closing = true;
        this.emit("close", reason);
        if (this.id !== "") this.signaling.send({
            type: "close",
            id: this.id,
            reason: reason ?? "normal closure"
        });
        this.peers.forEach((peer)=>peer.close(reason));
        this.signaling.close();
        if (typeof window !== "undefined") window.removeEventListener("unload", this.unloadListener);
    }
    send(channel, peerID, data) {
        if (!(channel in this.dataChannels)) throw new Error("unknown channel " + channel);
        if (this.peers.has(peerID)) this.peers.get(peerID)?.send(channel, data);
    }
    broadcast(channel, data) {
        if (!(channel in this.dataChannels)) throw new Error("unknown channel " + channel);
        this.peers.forEach((peer)=>peer.send(channel, data));
    }
    /**
   * @internal
   */ async _addPeer(id, polite) {
        const config = await this.credentials.fillCredentials(this.rtcConfig);
        config.iceServers = config.iceServers?.filter((server)=>!(server.urls.includes("turn:") && server.username === undefined));
        const peer = new (0, _peerDefault.default)(this, this.signaling, id, config, polite);
        this.peers.set(id, peer);
    }
    /**
   * @internal
   */ _removePeer(peer) {
        return this.peers.delete(peer.id);
    }
    /**
   * @internal
   */ _prefetchTURNCredentials() {
        this.credentials.fillCredentials(this.rtcConfig).catch(()=>{});
    }
    /**
   * @internal
   */ _onSignalingError(e) {
        this.emit("signalingerror", e);
        if (this.listenerCount("signalingerror") === 0) console.error("signallingerror not handled:", e);
        this.signaling.event("signaling", "error", {
            error: JSON.stringify(e)
        });
    }
    /**
   * @internal
   */ _forceReconnectSignaling() {
        this.signaling.close();
    }
    get id() {
        return this.signaling.receivedID ?? "";
    }
    get closing() {
        return this._closing;
    }
    get size() {
        return this.peers.size;
    }
    get currentLobby() {
        return this.signaling.currentLobby;
    }
    get currentLobbyLeader() {
        return this.signaling.currentLobbyLeader;
    }
}
exports.default = Network;

},{"eventemitter3":"3fnfh",".":"b74RF","./signaling":"ljuDa","./peer":"luyH0","./credentials":"aZfNA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3fnfh":[function(require,module,exports) {
"use strict";
var has = Object.prototype.hasOwnProperty, prefix = "~";
/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */ function Events() {}
//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
    Events.prototype = Object.create(null);
    //
    // This hack is needed because the `__proto__` property is still inherited in
    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
    //
    if (!new Events().__proto__) prefix = false;
}
/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */ function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
}
/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */ function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") throw new TypeError("The listener must be a function");
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [
        emitter._events[evt],
        listener
    ];
    return emitter;
}
/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */ function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
}
/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */ function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
}
/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */ EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0) return names;
    for(name in events = this._events)if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    if (Object.getOwnPropertySymbols) return names.concat(Object.getOwnPropertySymbols(events));
    return names;
};
/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */ EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [
        handlers.fn
    ];
    for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++)ee[i] = handlers[i].fn;
    return ee;
};
/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */ EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
};
/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */ EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
        switch(len){
            case 1:
                return listeners.fn.call(listeners.context), true;
            case 2:
                return listeners.fn.call(listeners.context, a1), true;
            case 3:
                return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
                return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for(i = 1, args = new Array(len - 1); i < len; i++)args[i - 1] = arguments[i];
        listeners.fn.apply(listeners.context, args);
    } else {
        var length = listeners.length, j;
        for(i = 0; i < length; i++){
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
            switch(len){
                case 1:
                    listeners[i].fn.call(listeners[i].context);
                    break;
                case 2:
                    listeners[i].fn.call(listeners[i].context, a1);
                    break;
                case 3:
                    listeners[i].fn.call(listeners[i].context, a1, a2);
                    break;
                case 4:
                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                    break;
                default:
                    if (!args) for(j = 1, args = new Array(len - 1); j < len; j++)args[j - 1] = arguments[j];
                    listeners[i].fn.apply(listeners[i].context, args);
            }
        }
    }
    return true;
};
/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
};
/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
};
/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return this;
    if (!fn) {
        clearEvent(this, evt);
        return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) clearEvent(this, evt);
    } else {
        for(var i = 0, events = [], length = listeners.length; i < length; i++)if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) events.push(listeners[i]);
        //
        // Reset the array, or remove it completely if we have no more listeners.
        //
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
    }
    return this;
};
/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
    } else {
        this._events = new Events();
        this._eventsCount = 0;
    }
    return this;
};
//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;
//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;
//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;
module.exports = EventEmitter;

},{}],"ljuDa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SignalingError", ()=>SignalingError);
var _eventemitter3 = require("eventemitter3");
class Signaling extends (0, _eventemitter3.EventEmitter) {
    constructor(network, peers, url){
        super();
        this.network = network;
        this.reconnectAttempt = 0;
        this.reconnecting = false;
        this.requests = new Map();
        this.url = url;
        this.connections = peers;
        this.replayQueue = new Map();
        this.ws = this.connect();
    }
    connect() {
        const ws = new WebSocket(this.url);
        const onOpen = ()=>{
            this.reconnectAttempt = 0;
            this.reconnecting = false;
            this.send({
                type: "hello",
                game: this.network.gameID,
                id: this.receivedID,
                secret: this.receivedSecret
            });
        };
        const onError = (e)=>{
            const error = new SignalingError("socket-error", "unexpected websocket error", e);
            this.network._onSignalingError(error);
            if (ws.readyState === WebSocket.CLOSED) {
                this.reconnecting = false;
                ws.removeEventListener("open", onOpen);
                ws.removeEventListener("error", onError);
                ws.removeEventListener("message", onMessage);
                ws.removeEventListener("close", onClose);
                this.reconnect();
            }
        };
        const onMessage = (ev)=>{
            this.handleSignalingMessage(ev.data).catch((_)=>{});
        };
        const onClose = ()=>{
            if (!this.network.closing) {
                const error = new SignalingError("socket-error", "signaling socket closed");
                this.network._onSignalingError(error);
            }
            ws.removeEventListener("open", onOpen);
            ws.removeEventListener("error", onError);
            ws.removeEventListener("message", onMessage);
            ws.removeEventListener("close", onClose);
            this.reconnect();
        };
        ws.addEventListener("open", onOpen);
        ws.addEventListener("error", onError);
        ws.addEventListener("message", onMessage);
        ws.addEventListener("close", onClose);
        return ws;
    }
    reconnect() {
        if (this.reconnecting || this.network.closing) return;
        this.close();
        this.requests.forEach((r)=>r.reject(new SignalingError("socket-error", "signaling socket closed")));
        this.requests.clear();
        if (this.reconnectAttempt > 42) {
            this.network.emit("failed");
            this.network._onSignalingError(new SignalingError("socket-error", "giving up on reconnecting to signaling server"));
            return;
        }
        this.event("signaling", "attempt-reconnect");
        this.reconnecting = true;
        setTimeout(()=>{
            this.ws = this.connect();
        }, Math.random() * 100 * this.reconnectAttempt);
        this.reconnectAttempt += 1;
    }
    close() {
        this.ws.close();
    }
    async request(packet) {
        return await new Promise((resolve, reject)=>{
            if (this.ws.readyState !== WebSocket.OPEN) reject(new SignalingError("socket-error", "signaling socket not open"));
            const rid = Math.random().toString(36).slice(2);
            packet.rid = rid;
            this.network.log("requesting signaling packet:", packet.type);
            const data = JSON.stringify(packet);
            this.ws.send(data);
            this.requests.set(rid, {
                resolve,
                reject
            });
        });
    }
    send(packet) {
        if (this.ws.readyState === WebSocket.OPEN) {
            this.network.log("sending signaling packet:", packet.type);
            const data = JSON.stringify(packet);
            this.ws.send(data);
        }
    }
    async handleSignalingMessage(data) {
        try {
            const packet = JSON.parse(data);
            this.network.log("signaling packet received:", packet.type);
            if (packet.rid !== undefined) {
                const request = this.requests.get(packet.rid);
                if (request != null) {
                    this.requests.delete(packet.rid);
                    if (packet.type === "error") request.reject(new SignalingError("server-error", packet.message));
                    else request.resolve(packet);
                }
            }
            switch(packet.type){
                case "error":
                    {
                        const error = new SignalingError("server-error", packet.message);
                        this.network._onSignalingError(error);
                        if (packet.code === "missing-recipient" && packet.error?.recipient !== undefined) {
                            const id = packet.error?.recipient;
                            if (this.connections.has(id)) {
                                this.network.log("cleaning up missing recipient", id);
                                this.connections.get(id)?.close("missing-recipient");
                            }
                        }
                    }
                    break;
                case "welcome":
                    if (this.receivedID !== undefined) {
                        this.network.log("signaling reconnected");
                        this.network.emit("signalingreconnected");
                        return;
                    }
                    if (packet.id === "") throw new Error("missing id on received welcome packet");
                    this.receivedID = packet.id;
                    this.receivedSecret = packet.secret;
                    this.network.emit("ready");
                    this.network._prefetchTURNCredentials();
                    break;
                case "joined":
                    if (packet.lobby === "") throw new Error("missing lobby on received connect packet");
                    this.currentLobby = packet.lobby;
                    this.currentLobbyLeader = packet.leader;
                    this.network.emit("lobby", packet.lobby, packet.leader);
                    break;
                case "connect":
                    if (this.receivedID === packet.id) return; // Skip self
                    await this.network._addPeer(packet.id, packet.polite);
                    for (const p of this.replayQueue.get(packet.id) ?? [])await this.connections.get(packet.id)?._onSignalingMessage(p);
                    this.replayQueue.delete(packet.id);
                    break;
                case "disconnect":
                    if (this.connections.has(packet.id)) this.connections.get(packet.id)?.close();
                    break;
                case "candidate":
                case "description":
                    if (this.connections.has(packet.source)) await this.connections.get(packet.source)?._onSignalingMessage(packet);
                    else {
                        const queue = this.replayQueue.get(packet.source) ?? [];
                        queue.push(packet);
                        this.replayQueue.set(packet.source, queue);
                    }
                    break;
                case "credentials":
                    this.emit("credentials", packet);
                    break;
                case "ping":
                    break;
                case "leader":
                    this.currentLobbyLeader = packet.id;
                    this.network.emit("leader", packet.id);
                    break;
            }
        } catch (e) {
            const error = new SignalingError("unknown-error", e);
            this.network._onSignalingError(error);
        }
    }
    async event(category, action, data) {
        return await new Promise((resolve)=>{
            setTimeout(()=>{
                this.send({
                    type: "event",
                    game: this.network.gameID,
                    lobby: this.currentLobby,
                    peer: this.network.id,
                    category,
                    action,
                    data
                });
                resolve();
            }, 0);
        });
    }
}
exports.default = Signaling;
class SignalingError {
    /**
   * @internal
   */ constructor(type, message, event){
        this.type = type;
        this.message = message;
        this.event = event;
    }
    toString() {
        return `[${this.type}: ${this.message}]`;
    }
}

},{"eventemitter3":"3fnfh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"luyH0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _signaling = require("./signaling");
var _latency = require("./latency");
var _latencyDefault = parcelHelpers.interopDefault(_latency);
const LatencyRestartIceThreshold = 1000 // ms
;
const ReconnectionWindow = 8000 // ms
;
class Peer {
    /**
   * @internal
   */ constructor(network, signaling, id, config, polite){
        this.network = network;
        this.signaling = signaling;
        this.id = id;
        this.config = config;
        this.polite = polite;
        this.makingOffer = false;
        this.ignoreOffer = false;
        this.isSettingRemoteAnswerPending = false;
        this.opened = false;
        this.closing = false;
        this.reconnecting = false;
        this.abortReconnectionAt = 0;
        this.allowNextManualRestartIceAt = 0;
        this.latency = new (0, _latencyDefault.default)(this);
        this.lastMessageReceivedAt = 0;
        this.channels = {};
        this.network.log("creating peer");
        this.testSessionWrapper = undefined;
        this.conn = new RTCPeerConnection(config);
        if (config.testproxyURL === undefined) this.conn.addEventListener("icecandidate", (e)=>{
            const candidate = e.candidate;
            if (candidate !== null) signaling.send({
                type: "candidate",
                source: this.network.id,
                recipient: this.id,
                candidate
            });
        });
        else this.testSessionWrapper = wrapSessionDescription;
        this.conn.addEventListener("negotiationneeded", ()=>{
            this.politenessTimeout = setTimeout(()=>{
                (async ()=>{
                    try {
                        if (this.closing) return;
                        this.makingOffer = true;
                        await this.conn.setLocalDescription();
                        const description = this.conn.localDescription;
                        if (description != null) {
                            await this.testSessionWrapper?.(description, this.config, this.network.id, this.id);
                            this.signaling.send({
                                type: "description",
                                source: this.network.id,
                                recipient: this.id,
                                description
                            });
                        }
                    } catch (e) {
                        const error = new (0, _signaling.SignalingError)("unknown-error", e);
                        this.network._onSignalingError(error);
                    } finally{
                        this.makingOffer = false;
                    }
                })().catch((_)=>{});
            }, this.polite ? 100 : 0);
        });
        this.checkStateInterval = setInterval(()=>{
            this.checkState();
        }, 500);
        this.conn.addEventListener("signalingstatechange", ()=>this.checkState());
        this.conn.addEventListener("connectionstatechange", ()=>this.checkState());
        this.conn.addEventListener("iceconnectionstatechange", ()=>this.checkState());
        this.network.emit("connecting", this);
        let i = 0;
        for(const label in this.network.dataChannels){
            const chan = this.conn.createDataChannel(label, {
                ...this.network.dataChannels[label],
                id: i++,
                negotiated: true
            });
            chan.binaryType = "arraybuffer";
            chan.addEventListener("error", (e)=>this.onError(e));
            chan.addEventListener("closing", ()=>this.checkState());
            chan.addEventListener("close", ()=>this.checkState());
            chan.addEventListener("open", ()=>{
                if (!this.opened && !Object.values(this.channels).some((c)=>c.readyState !== "open")) {
                    if ("control" in this.channels) this.latency = new (0, _latencyDefault.default)(this, this.channels.control);
                    if (this.politenessTimeout !== undefined) clearTimeout(this.politenessTimeout);
                    this.signaling.send({
                        type: "connected",
                        id: this.id
                    });
                    this.opened = true;
                    this.network.emit("connected", this);
                    this.signaling.event("rtc", "connected", {
                        target: this.id
                    });
                    this.reportLatencyEventTimeout = setTimeout(()=>{
                        this.signaling.event("rtc", "avg-latency-at-10s", {
                            target: this.id,
                            latency: `${this.latency.average}`
                        });
                    }, 10000);
                }
            });
            chan.addEventListener("message", (e)=>{
                this.lastMessageReceivedAt = performance.now();
                if (label !== "control") this.network.emit("message", this, label, e.data);
            });
            this.channels[label] = chan;
        }
    }
    close(reason) {
        if (this.closing) return;
        this.closing = true;
        // Inform signaling server that the peer has been disconnected:
        this.signaling.send({
            type: "disconnected",
            id: this.id,
            reason: reason ?? "normal closure"
        });
        Object.values(this.channels).forEach((c)=>c.close());
        this.conn.close();
        this.network._removePeer(this);
        if (this.checkStateInterval != null) clearInterval(this.checkStateInterval);
        if (this.reportLatencyEventTimeout != null) clearTimeout(this.reportLatencyEventTimeout);
        if (this.opened) {
            this.network.emit("disconnected", this);
            this.signaling.event("rtc", "disconnected", {
                target: this.id,
                reason: reason ?? "",
                reconnecting: this.reconnecting ? "true" : "false"
            });
        }
    }
    checkState() {
        const now = performance.now();
        const connectionState = this.conn.connectionState ?? this.conn.iceConnectionState;
        if (this.closing) return;
        if (!this.opened) {
            if (connectionState === "failed") this.close("connecting failed");
            return;
        }
        if (Object.values(this.channels).some((c)=>c.readyState !== "open")) this.close("data channel closed");
        // console.log('state', this.id, this.conn.connectionState, this.conn.iceConnectionState, Object.values(this.channels).map(c => c.readyState))
        if (!this.reconnecting && (connectionState === "disconnected" || connectionState === "failed")) {
            this.reconnecting = true;
            this.abortReconnectionAt = now + ReconnectionWindow;
            this.network.emit("reconnecting", this);
            this.signaling.event("rtc", "attempt-reconnect", {
                target: this.id
            });
        } else if (this.reconnecting && connectionState === "connected") {
            this.reconnecting = false;
            this.network.emit("reconnected", this);
            this.signaling.event("rtc", "attempt-reconnected", {
                target: this.id
            });
        } else if (this.reconnecting && now > this.abortReconnectionAt) this.close("reconnection timed out");
        if (!this.reconnecting && "control" in this.channels) {
            const lastPing = this.lastMessageReceivedAt;
            if (lastPing !== 0) {
                const delta = now - lastPing;
                if (delta > LatencyRestartIceThreshold && now > this.allowNextManualRestartIceAt) {
                    this.allowNextManualRestartIceAt = now + 10000;
                    this.conn.restartIce();
                }
            }
        }
    }
    onError(e) {
        this.network.emit("rtcerror", e);
        if (this.network.listenerCount("rtcerror") === 0) console.error("rtcerror not handled:", e);
        this.checkState();
        this.signaling.event("rtc", "error", {
            target: this.id,
            error: JSON.stringify(e)
        });
    }
    /**
   * @internal
   */ async _onSignalingMessage(packet) {
        switch(packet.type){
            case "candidate":
                if (packet.candidate != null) try {
                    await this.conn.addIceCandidate(packet.candidate);
                } catch (e) {
                    if (!this.ignoreOffer) throw e;
                }
                break;
            case "description":
                {
                    const { description  } = packet;
                    const readyForOffer = !this.makingOffer && (this.conn.signalingState === "stable" || this.isSettingRemoteAnswerPending);
                    const offerCollision = description.type === "offer" && !readyForOffer;
                    this.ignoreOffer = !this.polite && offerCollision;
                    if (this.ignoreOffer) return;
                    this.isSettingRemoteAnswerPending = description.type === "answer";
                    await this.conn.setRemoteDescription(description);
                    this.isSettingRemoteAnswerPending = false;
                    if (description.type === "offer") {
                        await this.conn.setLocalDescription();
                        const description = this.conn.localDescription;
                        if (description != null) {
                            await this.testSessionWrapper?.(description, this.config, this.network.id, this.id);
                            this.signaling.send({
                                type: "description",
                                source: this.network.id,
                                recipient: this.id,
                                description
                            });
                        }
                    }
                }
                break;
        }
    }
    send(channel, data) {
        if (!(channel in this.channels)) throw new Error("unknown channel " + channel);
        const chan = this.channels[channel];
        if (chan.readyState === "open") chan.send(data);
    }
    toString() {
        return `[Peer: ${this.id}]`;
    }
}
exports.default = Peer;
async function wrapSessionDescription(desc, config, selfID, otherID) {
    if (config.testproxyURL === undefined) return;
    let lines = desc.sdp.split("\r\n");
    lines = lines.filter((l)=>{
        return !l.startsWith("a=candidate") || l.includes("127.0.0.1") && l.includes("udp");
    });
    for(let i = 0; i < lines.length; i++){
        const l = lines[i];
        if (l.startsWith("a=candidate") && l.includes("127.0.0.1")) {
            const orignalPort = l.split("127.0.0.1 ").pop()?.split(" ")[0] // find port
            ;
            if (orignalPort != null) {
                const resp = await fetch(`${config.testproxyURL}/create?id=${selfID + otherID}&port=${orignalPort}`);
                const substitudePort = await resp.text();
                lines[i] = l.replaceAll(` ${orignalPort} `, ` ${substitudePort} `);
            }
        }
    }
    desc.sdp = lines.join("\r\n");
}

},{"./signaling":"ljuDa","./latency":"9RfE1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9RfE1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const PingInterval = 500;
const WindowSampleSize = 50;
const PING = "ping";
const PONG = "pong";
class Latency {
    /**
   * @internal
   */ constructor(peer, control){
        this.peer = peer;
        this.control = control;
        this.window = [];
        this.lastPingSentAt = 0;
        this.last = 0;
        this.average = 0;
        this.jitter = 0;
        this.max = 0;
        this.min = 0;
        if (control !== undefined) {
            this.ping();
            control.addEventListener("message", (e)=>this.onMessage(e.data));
        }
    }
    ping() {
        this.lastPingSentAt = performance.now();
        if (this.control?.readyState === "open") this.control?.send(PING);
    }
    onMessage(data) {
        if (data === PING) {
            if (this.control?.readyState === "open") this.control?.send(PONG);
            return;
        }
        if (data !== PONG) return;
        const now = performance.now();
        const delta = now - this.lastPingSentAt;
        this.window.unshift(delta);
        if (this.window.length > WindowSampleSize) this.window.pop();
        this.last = delta;
        this.max = Math.max(...this.window);
        this.min = Math.min(...this.window);
        this.average = this.window.reduce((a, b)=>a + b, 0) / this.window.length;
        if (this.window.length > 1) this.jitter = this.window.slice(1).map((x, i)=>Math.abs(x - this.window[i])).reduce((a, b)=>a + b, 0) / (this.window.length - 1);
        setTimeout(()=>this.ping(), PingInterval - delta);
    }
}
exports.default = Latency;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}]},["kv0No"], "kv0No", "parcelRequire59bb")

//# sourceMappingURL=index.4b4806ae.js.map
