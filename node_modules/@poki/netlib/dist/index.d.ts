import { EventEmitter } from "eventemitter3";
interface PeerConfiguration extends RTCConfiguration {
}
interface LobbySettings {
    codeFormat?: 'default' | 'short';
    codeLength?: number;
    maxPlayers?: number;
    password?: string;
    public?: boolean;
    customData?: {
        [key: string]: any;
    };
    canUpdateBy?: 'creator' | 'leader' | 'anyone' | 'none';
}
interface LobbyListEntry {
    code: string;
    public: boolean;
    playerCount: number;
    maxPlayers: number;
    hasPassword: boolean;
    customData?: {
        [key: string]: any;
    };
    leader?: string;
    term: number;
    createdAt: string;
    updatedAt: string;
}
declare class Latency {
    last: number;
    average: number;
    jitter: number;
    max: number;
    min: number;
}
declare class Peer {
    readonly id: string;
    readonly config: PeerConfiguration;
    readonly conn: RTCPeerConnection;
    latency: Latency;
    close(reason?: string): void;
    send(channel: string, data: string | Blob | ArrayBuffer | ArrayBufferView): void;
    toString(): string;
}
interface NetworkListeners {
    ready: () => void | Promise<void>;
    lobby: (code: string, lobbyInfo: LobbyListEntry) => void | Promise<void>;
    leader: (leader: string) => void | Promise<void>;
    lobbyUpdated: (code: string, settings: LobbySettings) => void | Promise<void>;
    connecting: (peer: Peer) => void | Promise<void>;
    connected: (peer: Peer) => void | Promise<void>;
    reconnecting: (peer: Peer) => void | Promise<void>;
    reconnected: (peer: Peer) => void | Promise<void>;
    disconnected: (peer: Peer) => void | Promise<void>;
    signalingreconnected: () => void | Promise<void>;
    failed: () => void | Promise<void>;
    message: (peer: Peer, channel: string, data: string | Blob | ArrayBuffer | ArrayBufferView) => void | Promise<void>;
    close: (reason?: string) => void | Promise<void>;
    rtcerror: (e: Event) => void | Promise<void>;
    signalingerror: (e: SignalingError) => void | Promise<void>;
}
export class Network extends EventEmitter<NetworkListeners> {
    readonly gameID: string;
    readonly peers: Map<string, Peer>;
    dataChannels: {
        [label: string]: RTCDataChannelInit;
    };
    log: (...data: any[]) => void;
    constructor(gameID: string, rtcConfig?: PeerConfiguration, signalingURL?: string);
    list(filter?: object): Promise<LobbyListEntry[]>;
    create(settings?: LobbySettings): Promise<string>;
    join(lobby: string, password?: string): Promise<LobbyListEntry | undefined>;
    setLobbySettings(settings: LobbySettings): Promise<true | Error>;
    close(reason?: string): void;
    send(channel: string, peerID: string, data: string | Blob | ArrayBuffer | ArrayBufferView): void;
    broadcast(channel: string, data: string | Blob | ArrayBuffer | ArrayBufferView): void;
    get id(): string;
    get closing(): boolean;
    get size(): number;
    get currentLobby(): string | undefined;
    get currentLobbyInfo(): LobbyListEntry | undefined;
    get currentLeader(): string | null | undefined;
}
declare class SignalingError {
    type: 'unknown-error' | 'socket-error' | 'server-error';
    message: string;
    event?: Event | undefined;
    code?: string | undefined;
    toString(): string;
}
export const DefaultSignalingURL: string;
export const DefaultRTCConfiguration: PeerConfiguration;
export const DefaultDataChannels: {
    [label: string]: RTCDataChannelInit;
};

//# sourceMappingURL=index.d.ts.map
