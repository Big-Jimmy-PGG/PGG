var $c9i1M$eventemitter3 = require("eventemitter3");


function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$export(module.exports, "DefaultSignalingURL", function () { return $87208ee2395edd08$export$f26023e62b577463; });
$parcel$export(module.exports, "DefaultRTCConfiguration", function () { return $87208ee2395edd08$export$34c0e73c967be630; });
$parcel$export(module.exports, "DefaultDataChannels", function () { return $87208ee2395edd08$export$3e03293f7176f9b3; });
$parcel$export(module.exports, "Network", function () { return $a3e583e87a964a6f$export$2e2bcd8739ae039; });
const $21698a8a5c043574$var$FetchTimeout = 5000;
const $21698a8a5c043574$export$3be8bbe0727053e5 = "turn:turn.rtc.poki.com";
class $21698a8a5c043574$export$2e2bcd8739ae039 {
    signaling;
    cachedCredentials;
    cachedCredentialsExpireAt;
    runningPromise;
    constructor(signaling){
        this.signaling = signaling;
        this.cachedCredentialsExpireAt = 0;
    }
    async fillCredentials(config) {
        const cloned = JSON.parse(JSON.stringify(config));
        if (config.testproxyURL !== undefined) return cloned;
        const hasPokiTurn = cloned.iceServers?.some((s)=>s.urls === $21698a8a5c043574$export$3be8bbe0727053e5 || s.urls.includes($21698a8a5c043574$export$3be8bbe0727053e5)) ?? false;
        if (!hasPokiTurn || cloned.iceServers === undefined) return cloned;
        if (this.runningPromise === undefined) this.runningPromise = new Promise((resolve)=>{
            if (this.cachedCredentials != null && this.cachedCredentialsExpireAt > performance.now()) {
                resolve(this.cachedCredentials);
                return;
            }
            this.signaling.request({
                type: "credentials"
            }).then((credentials)=>{
                if (credentials.type === "credentials") {
                    this.cachedCredentials = credentials;
                    this.cachedCredentialsExpireAt = performance.now() + ((credentials.lifetime ?? 0) - 60) * 1000;
                    resolve(credentials);
                }
            }).catch(()=>{
                resolve({
                    type: "credentials"
                });
                this.cachedCredentials = {
                    type: "credentials"
                };
                this.cachedCredentialsExpireAt = performance.now() + $21698a8a5c043574$var$FetchTimeout;
            });
            setTimeout(()=>{
                resolve({
                    type: "credentials"
                });
                this.cachedCredentials = {
                    type: "credentials"
                };
                this.cachedCredentialsExpireAt = performance.now() + $21698a8a5c043574$var$FetchTimeout;
            }, $21698a8a5c043574$var$FetchTimeout);
        });
        const credentials = await this.runningPromise;
        this.runningPromise = undefined;
        if (credentials.url === undefined) return cloned;
        cloned.iceServers.forEach((s)=>{
            if (s.urls === $21698a8a5c043574$export$3be8bbe0727053e5 || s.urls.includes($21698a8a5c043574$export$3be8bbe0727053e5)) {
                s.urls = credentials.url ?? "";
                s.username = credentials.username;
                s.credential = credentials.credential;
            }
        });
        return cloned;
    }
}





class $9f9f06bbd862f032$export$2e2bcd8739ae039 extends (0, $c9i1M$eventemitter3.EventEmitter) {
    network;
    url;
    ws;
    reconnectAttempt;
    reconnecting;
    receivedID;
    receivedSecret;
    currentLobby;
    currentLobbyInfo;
    currentLeader;
    currentTerm;
    connections;
    replayQueue;
    requests;
    constructor(network, peers, url){
        super();
        this.network = network;
        this.reconnectAttempt = 0;
        this.reconnecting = false;
        this.currentTerm = 0;
        this.requests = new Map();
        this.url = url;
        this.connections = peers;
        this.replayQueue = new Map();
        this.ws = this.connect();
    }
    connect() {
        const ws = new WebSocket(this.url);
        const onOpen = ()=>{
            this.reconnectAttempt = 0;
            this.reconnecting = false;
            this.send({
                type: "hello",
                game: this.network.gameID,
                id: this.receivedID,
                secret: this.receivedSecret
            });
        };
        const onError = (e)=>{
            const error = new $9f9f06bbd862f032$export$4299251c42ef608f("socket-error", "unexpected websocket error", e);
            this.network._onSignalingError(error);
            if (ws.readyState === WebSocket.CLOSED) {
                this.reconnecting = false;
                ws.removeEventListener("open", onOpen);
                ws.removeEventListener("error", onError);
                ws.removeEventListener("message", onMessage);
                ws.removeEventListener("close", onClose);
                // Don't try to reconnect too quickly, give the server a chance
                // to store our disconnection in the db, so when we reconnect
                // it recognizes us.
                setTimeout(()=>{
                    this.reconnect();
                }, 100);
            }
        };
        const onMessage = (ev)=>{
            this.handleSignalingMessage(ev.data).catch((_)=>{});
        };
        const onClose = ()=>{
            if (!this.network.closing) {
                const error = new $9f9f06bbd862f032$export$4299251c42ef608f("socket-error", "signaling socket closed");
                this.network._onSignalingError(error);
            }
            ws.removeEventListener("open", onOpen);
            ws.removeEventListener("error", onError);
            ws.removeEventListener("message", onMessage);
            ws.removeEventListener("close", onClose);
            // Don't try to reconnect too quickly, give the server a chance
            // to store our disconnection in the db, so when we reconnect
            // it recognizes us.
            setTimeout(()=>{
                this.reconnect();
            }, 100);
        };
        ws.addEventListener("open", onOpen);
        ws.addEventListener("error", onError);
        ws.addEventListener("message", onMessage);
        ws.addEventListener("close", onClose);
        return ws;
    }
    reconnect() {
        if (this.reconnecting || this.network.closing) return;
        this.close();
        this.requests.forEach((r)=>r.reject(new $9f9f06bbd862f032$export$4299251c42ef608f("socket-error", "signaling socket closed")));
        this.requests.clear();
        if (this.reconnectAttempt > 42) {
            this.network.emit("failed");
            this.network._onSignalingError(new $9f9f06bbd862f032$export$4299251c42ef608f("socket-error", "giving up on reconnecting to signaling server"));
            return;
        }
        this.event("signaling", "attempt-reconnect");
        this.reconnecting = true;
        setTimeout(()=>{
            this.ws = this.connect();
        }, Math.random() * 100 * this.reconnectAttempt);
        this.reconnectAttempt += 1;
    }
    close() {
        this.ws.close();
    }
    async request(packet) {
        return await new Promise((resolve, reject)=>{
            if (this.ws.readyState !== WebSocket.OPEN) reject(new $9f9f06bbd862f032$export$4299251c42ef608f("socket-error", "signaling socket not open"));
            const rid = Math.random().toString(36).slice(2);
            packet.rid = rid;
            this.network.log("requesting signaling packet:", packet.type);
            const data = JSON.stringify(packet);
            this.ws.send(data);
            this.requests.set(rid, {
                resolve: resolve,
                reject: reject
            });
        });
    }
    send(packet) {
        if (this.ws.readyState === WebSocket.OPEN) {
            this.network.log("sending signaling packet:", packet.type);
            const data = JSON.stringify(packet);
            this.ws.send(data);
        }
    }
    async handleSignalingMessage(data) {
        try {
            const packet = JSON.parse(data);
            this.network.log("signaling packet received:", packet.type);
            if (packet.rid !== undefined) {
                const request = this.requests.get(packet.rid);
                if (request != null) {
                    this.requests.delete(packet.rid);
                    if (packet.type === "error") request.reject(new $9f9f06bbd862f032$export$4299251c42ef608f("server-error", packet.message, undefined, packet.code));
                    else request.resolve(packet);
                }
            }
            switch(packet.type){
                case "error":
                    {
                        const error = new $9f9f06bbd862f032$export$4299251c42ef608f("server-error", packet.message, undefined, packet.code);
                        this.network._onSignalingError(error);
                        if (packet.code === "missing-recipient" && packet.error?.recipient !== undefined) {
                            const id = packet.error?.recipient;
                            if (this.connections.has(id)) {
                                this.network.log("cleaning up missing recipient", id);
                                this.connections.get(id)?.close("missing-recipient");
                            }
                        } else if (packet.code === "reconnect-failed") this.network.close("reconnect failed");
                    }
                    break;
                case "welcome":
                    if (this.receivedID !== undefined) {
                        this.network.log("signaling reconnected");
                        this.network.emit("signalingreconnected");
                        return;
                    }
                    if (packet.id === "") throw new Error("missing id on received welcome packet");
                    this.receivedID = packet.id;
                    this.receivedSecret = packet.secret;
                    this.network.emit("ready");
                    this.network._prefetchTURNCredentials();
                    break;
                case "joined":
                    {
                        const code = packet.lobbyInfo.code;
                        if (code === "") throw new Error("missing lobby on received connect packet");
                        this.currentLobby = code;
                        this.currentLeader = packet.lobbyInfo.leader;
                        this.currentTerm = packet.lobbyInfo.term;
                        this.network.emit("lobby", code, packet.lobbyInfo);
                        if (this.currentLeader !== undefined) this.network.emit("leader", this.currentLeader);
                    }
                    break;
                case "leader":
                    if (this.currentLobby === undefined) // We're not in a lobby, ignore leader packets.
                    return;
                    if (packet.term > this.currentTerm) {
                        this.currentLeader = packet.leader;
                        this.currentTerm = packet.term;
                        this.network.emit("leader", packet.leader);
                    }
                    break;
                case "lobbyUpdated":
                    if (this.currentLobby === undefined) // We're not in a lobby, ignore updated packets.
                    return;
                    this.currentLobbyInfo = packet.lobbyInfo;
                    this.network.emit("lobbyUpdated", packet.lobbyInfo.code, packet.lobbyInfo);
                    break;
                case "connect":
                    if (this.receivedID === packet.id) return; // Skip self
                    await this.network._addPeer(packet.id, packet.polite);
                    for (const p of this.replayQueue.get(packet.id) ?? [])await this.connections.get(packet.id)?._onSignalingMessage(p);
                    this.replayQueue.delete(packet.id);
                    break;
                case "disconnect":
                    if (this.connections.has(packet.id)) this.connections.get(packet.id)?.close();
                    break;
                case "candidate":
                case "description":
                    if (this.connections.has(packet.source)) await this.connections.get(packet.source)?._onSignalingMessage(packet);
                    else {
                        const queue = this.replayQueue.get(packet.source) ?? [];
                        queue.push(packet);
                        this.replayQueue.set(packet.source, queue);
                    }
                    break;
                case "credentials":
                    this.emit("credentials", packet);
                    break;
                case "ping":
                    break;
            }
        } catch (e) {
            const error = new $9f9f06bbd862f032$export$4299251c42ef608f("unknown-error", e);
            this.network._onSignalingError(error);
        }
    }
    async event(category, action, data) {
        return await new Promise((resolve)=>{
            setTimeout(()=>{
                this.send({
                    type: "event",
                    game: this.network.gameID,
                    lobby: this.currentLobby,
                    peer: this.network.id,
                    category: category,
                    action: action,
                    data: data
                });
                resolve();
            }, 0);
        });
    }
}
class $9f9f06bbd862f032$export$4299251c42ef608f {
    type;
    message;
    event;
    code;
    /**
   * @internal
   */ constructor(type, message, event, code){
        this.type = type;
        this.message = message;
        this.event = event;
        this.code = code;
    }
    toString() {
        return `[${this.type}: ${this.message}]`;
    }
}



const $dad8d976b416fafe$var$PingInterval = 500;
const $dad8d976b416fafe$var$WindowSampleSize = 50;
const $dad8d976b416fafe$var$PING = "ping";
const $dad8d976b416fafe$var$PONG = "pong";
class $dad8d976b416fafe$export$2e2bcd8739ae039 {
    peer;
    control;
    window;
    lastPingSentAt;
    last;
    average;
    jitter;
    max;
    min;
    /**
   * @internal
   */ constructor(peer, control){
        this.peer = peer;
        this.control = control;
        this.window = [];
        this.lastPingSentAt = 0;
        this.last = 0;
        this.average = 0;
        this.jitter = 0;
        this.max = 0;
        this.min = 0;
        if (control !== undefined) {
            this.ping();
            control.addEventListener("message", (e)=>this.onMessage(e.data));
        }
    }
    ping() {
        this.lastPingSentAt = performance.now();
        if (this.control?.readyState === "open") this.control?.send($dad8d976b416fafe$var$PING);
    }
    onMessage(data) {
        if (data === $dad8d976b416fafe$var$PING) {
            if (this.control?.readyState === "open") this.control?.send($dad8d976b416fafe$var$PONG);
            return;
        }
        if (data !== $dad8d976b416fafe$var$PONG) return;
        const now = performance.now();
        const delta = now - this.lastPingSentAt;
        this.window.unshift(delta);
        if (this.window.length > $dad8d976b416fafe$var$WindowSampleSize) this.window.pop();
        this.last = delta;
        this.max = Math.max(...this.window);
        this.min = Math.min(...this.window);
        this.average = this.window.reduce((a, b)=>a + b, 0) / this.window.length;
        if (this.window.length > 1) this.jitter = this.window.slice(1).map((x, i)=>Math.abs(x - this.window[i])).reduce((a, b)=>a + b, 0) / (this.window.length - 1);
        setTimeout(()=>this.ping(), $dad8d976b416fafe$var$PingInterval - delta);
    }
}


const $95761353b7ef8987$var$LatencyRestartIceThreshold = 1000 // ms
;
const $95761353b7ef8987$var$ReconnectionWindow = 8000 // ms
;
class $95761353b7ef8987$export$2e2bcd8739ae039 {
    network;
    signaling;
    id;
    config;
    polite;
    conn;
    // Signaling state:
    makingOffer;
    ignoreOffer;
    isSettingRemoteAnswerPending;
    // Connection state:
    opened;
    closing;
    reconnecting;
    abortReconnectionAt;
    allowNextManualRestartIceAt;
    latency;
    lastMessageReceivedAt;
    politenessTimeout;
    reportLatencyEventTimeout;
    checkStateInterval;
    channels;
    testSessionWrapper;
    /**
   * @internal
   */ constructor(network, signaling, id, config, polite){
        this.network = network;
        this.signaling = signaling;
        this.id = id;
        this.config = config;
        this.polite = polite;
        this.makingOffer = false;
        this.ignoreOffer = false;
        this.isSettingRemoteAnswerPending = false;
        this.opened = false;
        this.closing = false;
        this.reconnecting = false;
        this.abortReconnectionAt = 0;
        this.allowNextManualRestartIceAt = 0;
        this.latency = new (0, $dad8d976b416fafe$export$2e2bcd8739ae039)(this);
        this.lastMessageReceivedAt = 0;
        this.channels = {};
        this.network.log("creating peer");
        this.testSessionWrapper = undefined;
        this.conn = new RTCPeerConnection(config);
        if (config.testproxyURL === undefined) this.conn.addEventListener("icecandidate", (e)=>{
            const candidate = e.candidate;
            if (candidate !== null) signaling.send({
                type: "candidate",
                source: this.network.id,
                recipient: this.id,
                candidate: candidate
            });
        });
        else this.testSessionWrapper = $95761353b7ef8987$var$wrapSessionDescription;
        this.conn.addEventListener("negotiationneeded", ()=>{
            this.politenessTimeout = setTimeout(()=>{
                (async ()=>{
                    try {
                        if (this.closing) return;
                        this.makingOffer = true;
                        await this.conn.setLocalDescription();
                        const description = this.conn.localDescription;
                        if (description != null) {
                            await this.testSessionWrapper?.(description, this.config, this.network.id, this.id);
                            this.signaling.send({
                                type: "description",
                                source: this.network.id,
                                recipient: this.id,
                                description: description
                            });
                        }
                    } catch (e) {
                        const error = new (0, $9f9f06bbd862f032$export$4299251c42ef608f)("unknown-error", e);
                        this.network._onSignalingError(error);
                    } finally{
                        this.makingOffer = false;
                    }
                })().catch((_)=>{});
            }, this.polite ? 100 : 0);
        });
        this.checkStateInterval = setInterval(()=>{
            this.checkState();
        }, 500);
        this.conn.addEventListener("signalingstatechange", ()=>this.checkState());
        this.conn.addEventListener("connectionstatechange", ()=>this.checkState());
        this.conn.addEventListener("iceconnectionstatechange", ()=>this.checkState());
        this.network.emit("connecting", this);
        let i = 0;
        for(const label in this.network.dataChannels){
            const chan = this.conn.createDataChannel(label, {
                ...this.network.dataChannels[label],
                id: i++,
                negotiated: true
            });
            chan.binaryType = "arraybuffer";
            chan.addEventListener("error", (e)=>this.onError(e));
            chan.addEventListener("closing", ()=>this.checkState());
            chan.addEventListener("close", ()=>this.checkState());
            chan.addEventListener("open", ()=>{
                if (!this.opened && !Object.values(this.channels).some((c)=>c.readyState !== "open")) {
                    if ("control" in this.channels) this.latency = new (0, $dad8d976b416fafe$export$2e2bcd8739ae039)(this, this.channels.control);
                    if (this.politenessTimeout !== undefined) clearTimeout(this.politenessTimeout);
                    this.signaling.send({
                        type: "connected",
                        id: this.id
                    });
                    this.opened = true;
                    this.network.emit("connected", this);
                    this.signaling.event("rtc", "connected", {
                        target: this.id
                    });
                    this.reportLatencyEventTimeout = setTimeout(()=>{
                        this.signaling.event("rtc", "avg-latency-at-10s", {
                            target: this.id,
                            latency: `${this.latency.average}`
                        });
                    }, 10000);
                }
            });
            chan.addEventListener("message", (e)=>{
                this.lastMessageReceivedAt = performance.now();
                if (label !== "control") this.network.emit("message", this, label, e.data);
            });
            this.channels[label] = chan;
        }
    }
    close(reason) {
        if (this.closing) return;
        this.closing = true;
        // Inform signaling server that the peer has been disconnected:
        this.signaling.send({
            type: "disconnected",
            id: this.id,
            reason: reason ?? "normal closure"
        });
        Object.values(this.channels).forEach((c)=>c.close());
        this.conn.close();
        this.network._removePeer(this);
        if (this.checkStateInterval != null) clearInterval(this.checkStateInterval);
        if (this.reportLatencyEventTimeout != null) clearTimeout(this.reportLatencyEventTimeout);
        if (this.opened) {
            this.network.emit("disconnected", this);
            this.signaling.event("rtc", "disconnected", {
                target: this.id,
                reason: reason ?? "",
                reconnecting: this.reconnecting ? "true" : "false"
            });
        }
    }
    checkState() {
        const now = performance.now();
        const connectionState = this.conn.connectionState ?? this.conn.iceConnectionState;
        if (this.closing) return;
        if (!this.opened) {
            if (connectionState === "failed") this.close("connecting failed");
            return;
        }
        if (Object.values(this.channels).some((c)=>c.readyState !== "open")) this.close("data channel closed");
        // console.log('state', this.id, this.conn.connectionState, this.conn.iceConnectionState, Object.values(this.channels).map(c => c.readyState))
        if (!this.reconnecting && (connectionState === "disconnected" || connectionState === "failed")) {
            this.reconnecting = true;
            this.abortReconnectionAt = now + $95761353b7ef8987$var$ReconnectionWindow;
            this.network.emit("reconnecting", this);
            this.signaling.event("rtc", "attempt-reconnect", {
                target: this.id
            });
        } else if (this.reconnecting && connectionState === "connected") {
            this.reconnecting = false;
            this.network.emit("reconnected", this);
            this.signaling.event("rtc", "attempt-reconnected", {
                target: this.id
            });
        } else if (this.reconnecting && now > this.abortReconnectionAt) this.close("reconnection timed out");
        if (!this.reconnecting && "control" in this.channels) {
            const lastPing = this.lastMessageReceivedAt;
            if (lastPing !== 0) {
                const delta = now - lastPing;
                if (delta > $95761353b7ef8987$var$LatencyRestartIceThreshold && now > this.allowNextManualRestartIceAt) {
                    this.allowNextManualRestartIceAt = now + 10000;
                    this.conn.restartIce();
                }
            }
        }
    }
    onError(e) {
        this.network.emit("rtcerror", e);
        if (this.network.listenerCount("rtcerror") === 0) console.error("rtcerror not handled:", e);
        this.checkState();
        this.signaling.event("rtc", "error", {
            target: this.id,
            error: JSON.stringify(e)
        });
    }
    /**
   * @internal
   */ async _onSignalingMessage(packet) {
        switch(packet.type){
            case "candidate":
                if (packet.candidate != null) try {
                    await this.conn.addIceCandidate(packet.candidate);
                } catch (e) {
                    if (!this.ignoreOffer) throw e;
                }
                break;
            case "description":
                {
                    const { description: description } = packet;
                    const readyForOffer = !this.makingOffer && (this.conn.signalingState === "stable" || this.isSettingRemoteAnswerPending);
                    const offerCollision = description.type === "offer" && !readyForOffer;
                    this.ignoreOffer = !this.polite && offerCollision;
                    if (this.ignoreOffer) return;
                    this.isSettingRemoteAnswerPending = description.type === "answer";
                    await this.conn.setRemoteDescription(description);
                    this.isSettingRemoteAnswerPending = false;
                    if (description.type === "offer") {
                        await this.conn.setLocalDescription();
                        const description = this.conn.localDescription;
                        if (description != null) {
                            await this.testSessionWrapper?.(description, this.config, this.network.id, this.id);
                            this.signaling.send({
                                type: "description",
                                source: this.network.id,
                                recipient: this.id,
                                description: description
                            });
                        }
                    }
                }
                break;
        }
    }
    send(channel, data) {
        if (!(channel in this.channels)) throw new Error("unknown channel " + channel);
        const chan = this.channels[channel];
        if (chan.readyState === "open") chan.send(data);
    }
    toString() {
        return `[Peer: ${this.id}]`;
    }
}
async function $95761353b7ef8987$var$wrapSessionDescription(desc, config, selfID, otherID) {
    if (config.testproxyURL === undefined) return;
    let lines = desc.sdp.split("\r\n");
    lines = lines.filter((l)=>{
        return !l.startsWith("a=candidate") || l.includes("127.0.0.1") && l.includes("udp");
    });
    for(let i = 0; i < lines.length; i++){
        const l = lines[i];
        if (l.startsWith("a=candidate") && l.includes("127.0.0.1")) {
            const orignalPort = l.split("127.0.0.1 ").pop()?.split(" ")[0] // find port
            ;
            if (orignalPort != null) {
                const resp = await fetch(`${config.testproxyURL}/create?id=${selfID + otherID}&port=${orignalPort}`);
                const substitudePort = await resp.text();
                lines[i] = l.replaceAll(` ${orignalPort} `, ` ${substitudePort} `);
            }
        }
    }
    desc.sdp = lines.join("\r\n");
}



class $a3e583e87a964a6f$export$2e2bcd8739ae039 extends (0, $c9i1M$eventemitter3.EventEmitter) {
    gameID;
    rtcConfig;
    _closing;
    peers;
    signaling;
    credentials;
    dataChannels;
    log;
    unloadListener;
    constructor(gameID, rtcConfig = (0, $87208ee2395edd08$export$34c0e73c967be630), signalingURL = (0, $87208ee2395edd08$export$f26023e62b577463)){
        super();
        this.gameID = gameID;
        this.rtcConfig = rtcConfig;
        this._closing = false;
        this.dataChannels = (0, $87208ee2395edd08$export$3e03293f7176f9b3);
        this.log = (...args)=>{} // console.log
        ;
        this.peers = new Map();
        this.signaling = new (0, $9f9f06bbd862f032$export$2e2bcd8739ae039)(this, this.peers, signalingURL);
        this.credentials = new (0, $21698a8a5c043574$export$2e2bcd8739ae039)(this.signaling);
        this.unloadListener = ()=>this.close();
        if (typeof window !== "undefined") window.addEventListener("unload", this.unloadListener);
    }
    async list(filter) {
        if (this._closing || this.signaling.receivedID === undefined) return [];
        const filterString = filter != null ? JSON.stringify(filter) : undefined;
        const reply = await this.signaling.request({
            type: "list",
            filter: filterString
        });
        if (reply.type === "lobbies") return reply.lobbies;
        return [];
    }
    async create(settings) {
        if (this._closing || this.signaling.receivedID === undefined) return "";
        const reply = await this.signaling.request({
            type: "create",
            ...settings
        });
        if (reply.type === "joined") return reply.lobbyInfo.code;
        return "";
    }
    async join(lobby, password) {
        if (this._closing || this.signaling.receivedID === undefined) return undefined;
        const reply = await this.signaling.request({
            type: "join",
            lobby: lobby,
            password: password
        });
        if (reply.type === "joined") return reply.lobbyInfo;
        return undefined;
    }
    async setLobbySettings(settings) {
        if (this._closing || this.signaling.receivedID === undefined) return new Error("network is closing or not connected");
        await this.signaling.request({
            type: "lobbyUpdate",
            ...settings
        });
        return true;
    }
    close(reason) {
        if (this._closing || this.signaling.receivedID === undefined) return;
        this._closing = true;
        this.emit("close", reason);
        if (this.id !== "") this.signaling.send({
            type: "close",
            id: this.id,
            reason: reason ?? "normal closure"
        });
        this.peers.forEach((peer)=>peer.close(reason));
        this.signaling.close();
        if (typeof window !== "undefined") window.removeEventListener("unload", this.unloadListener);
    }
    send(channel, peerID, data) {
        if (!(channel in this.dataChannels)) throw new Error("unknown channel " + channel);
        if (this.peers.has(peerID)) this.peers.get(peerID)?.send(channel, data);
    }
    broadcast(channel, data) {
        if (!(channel in this.dataChannels)) throw new Error("unknown channel " + channel);
        this.peers.forEach((peer)=>peer.send(channel, data));
    }
    /**
   * @internal
   */ async _addPeer(id, polite) {
        const config = await this.credentials.fillCredentials(this.rtcConfig);
        config.iceServers = config.iceServers?.filter((server)=>!(server.urls.includes("turn:") && server.username === undefined));
        const peer = new (0, $95761353b7ef8987$export$2e2bcd8739ae039)(this, this.signaling, id, config, polite);
        this.peers.set(id, peer);
    }
    /**
   * @internal
   */ _removePeer(peer) {
        return this.peers.delete(peer.id);
    }
    /**
   * @internal
   */ _prefetchTURNCredentials() {
        this.credentials.fillCredentials(this.rtcConfig).catch(()=>{});
    }
    /**
   * @internal
   */ _onSignalingError(e) {
        this.emit("signalingerror", e);
        if (this.listenerCount("signalingerror") === 0) console.error("signallingerror not handled:", e);
        this.signaling.event("signaling", "error", {
            error: JSON.stringify(e)
        });
    }
    /**
   * @internal
   */ _forceReconnectSignaling() {
        this.signaling.close();
    }
    get id() {
        return this.signaling.receivedID ?? "";
    }
    get closing() {
        return this._closing;
    }
    get size() {
        return this.peers.size;
    }
    get currentLobby() {
        return this.signaling.currentLobby;
    }
    get currentLobbyInfo() {
        return this.signaling.currentLobbyInfo;
    }
    get currentLeader() {
        return this.signaling.currentLeader;
    }
}


const $87208ee2395edd08$export$f26023e62b577463 = "wss://netlib.poki.io/v0/signaling";
const $87208ee2395edd08$export$34c0e73c967be630 = {
    iceServers: [
        {
            urls: [
                "stun:stun.l.google.com:19302"
            ]
        },
        {
            urls: (0, $21698a8a5c043574$export$3be8bbe0727053e5)
        }
    ]
};
const $87208ee2395edd08$export$3e03293f7176f9b3 = {
    reliable: {
        ordered: true
    },
    unreliable: {
        ordered: true,
        maxRetransmits: 0
    },
    control: {
        ordered: false
    }
};


//# sourceMappingURL=netlib.js.map
